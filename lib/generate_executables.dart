import 'package:path/path.dart' as p;
import 'package:suitcase/src/command_context.dart';
import 'package:suitcase/src/command_runner.dart';
import 'package:suitcase/src/utils/utils.dart';
import 'package:universal_io/io.dart';
import 'package:yaml_edit/yaml_edit.dart';

/// Generates linked executables for all suitcase commands.
///
/// This script will generate an executable Dart file in `bin/` for each
/// applicable command exposed by the [SuitcaseCommandRunner].
///
/// If [removeExisting] is `true` (the default), then any existing
/// executables will be removed before generating new ones.
///
/// For example, suppose the command runner contains commands `foo` and `bar`.
/// This script will generate the following files:
///
/// ```plaintext
/// bin/suitcase.dart
/// bin/foo.dart
/// bin/bar.dart
/// ```
Future<void> generateExecutables({
  bool removeExisting = true,
}) async {
  final packageDir = DirUtils.getPackageDir();

  if (Directory.current != packageDir) {
    context.logger.info('Changing working directory to package directory.');
    Directory.current = packageDir;
  }

  final binDir = Directory(p.join(Directory.current.path, 'bin'));
  if (!binDir.existsSync()) {
    final prog = context.logger.progress('Creating bin directory...');
    await binDir.create(recursive: true);
    prog.complete('Created bin directory.');
  }

  final commandFetchingProg = context.logger.progress('Fetching commands...');

  final commandRunner = SuitcaseCommandRunner();
  final commands = commandRunner.getLinkableCommands();
  final commandNames = commands.keys.toList();

  commandFetchingProg.complete('Fetched commands.');

  if (removeExisting) {
    final existingFileRemovalProg =
        context.logger.progress('Removing existing executables...');

    final existingFiles = binDir
        .listSync()
        .whereType<File>()
        .where((file) => file.path.endsWith('.dart'))
        // Except for the main executable
        .where((file) => file.path != p.join(binDir.path, 'suitcase.dart'))
        .toList();

    for (final file in existingFiles) {
      await file.delete();
    }

    existingFileRemovalProg
        .complete('Removed existing executables (${existingFiles.length}).');
  }

  final fileWritingProg = context.logger.progress('');

  for (final commandName in commandNames) {
    final commandFile = File(p.join(binDir.path, '$commandName.dart'));
    if (commandFile.existsSync()) {
      fileWritingProg.update("Overwriting '$commandName' executable...");
      await commandFile.delete();
    } else {
      fileWritingProg.update("Creating '$commandName' executable...");
    }
    await commandFile.writeAsString(_generateDartFileContents(commandName));
  }

  fileWritingProg.complete('Wrote executables.');

  final yamlEditProg = context.logger.progress('Updating pubspec.yaml...');
  final executableEntries = [packageName, ...commandNames];
  await _updatePubspecYamlExecutables(executableEntries);
  yamlEditProg.complete('Updated pubspec.yaml.');

  context.logger.success('Generated executables for the following commands:');
  for (final commandName in executableEntries) {
    context.logger.success('  $commandName');
  }
}

Future<void> _updatePubspecYamlExecutables(
  List<String> executableEntries,
) async {
  final pubspecYaml = File(p.join(Directory.current.path, 'pubspec.yaml'));

  const executablesKey = 'executables';

  final pubspecYamlDoc = YamlEditor(await pubspecYaml.readAsString())
    ..remove([executablesKey])
    ..update(
      [executablesKey],
      {
        for (final entry in executableEntries) entry: entry,
      },
    );

  pubspecYaml.writeAsStringSync(pubspecYamlDoc.toString());
}

String _generateDartFileContents(String commandName) {
  return '''
// THIS FILE WAS GENERATED. DO NOT MODIFY BY HAND.
//
// This file was generated by the `lib/generate_executables.dart` script, and
// functions as a wrapper around the `bin/suitcase.dart` executable that will
// invoke the `$commandName` command.

import 'package:suitcase/run_command_runner.dart';

Future<void> main(List<String> args) {
  return runCommandRunner(
    args,
    prefixedCommand: '$commandName',
  );
}
''';
}
